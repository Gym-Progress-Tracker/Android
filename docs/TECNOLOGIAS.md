### Tecnologias e implementação
A interface nativa foi escolhida pensando na experiência do usuário e melhor desempenho ao usar o armazenamento local. Aqui apresentaremos os motivos do porque usar tais tecnologias

#### Prototipação
- Penpot (Open Source e completo e pode criar páginas ilimitadas)
- Material Design Icons https://fonts.google.com/icons
- Open Color https://yeun.github.io/open-color/
- Radix UI Colors https://www.radix-ui.com/colors

#### Android
1. Kotlin (linguagem padrão)
2. Compose (facilidade no desenvolvimento da interface do usuário)
3. Compose Navigation (navegação entre telas no Compose)
4. Material Design (ótimo para usuários, já sabem o que esperar do app ao abri-lo)
5. Arquiterura MVVM (mais usada e excelente para escalar projetos)
6. Técnica de Type Safety Navigation (para navegação segura e evitar Exceptions)
7. Coroutines (necessidade de progrmação assíncrona)
8. Flow (para reatividade de dados)
9. Hilt (biblioteca mais usada para injeção de dependências)
10. Room (banco de dados local e abstração do SQLite)
11. DataStore (para salvar configurações do usuário, como autenticação)
12. Retrofit (para requisições REST e por ser o mais utilizado pelo mercado)
13. jUnit (para testes unitários)
14. Truth (biblioteca com sintaxe ótima para Asserções de Testes)
15. Compose UI Test (semelhante ao uso do Espresso, consegue testar a UI)
16. Mockito (biblioteca para Mocks mais utilizada no mundo Java e bem estabelecida no mercado)
17. Testes Unitários de Integração Contínua (CI) durante Pull Requests
18. Firebase Analytics
19. Firebase Crashlytics

#### iOS
Será decidido quando o projeto iOS se iniciar.
- Spoilers: Swift e SwiftUI
